<!doctype html>
<html lang="en">
<head>
<title>three.js webgl - terrain w/ trackball controls</title>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
<style>
body {
    color: #000;
    font-family: Monospace;
    font-size: 13px;
    text-align: center;
    font-weight: bold;

    background-color: #555;
    margin: 0px;
    overflow: hidden;
}

#info {
    color: #aaa;
    font-size: 16px;
    font-weight: bold;
    position: absolute;
    top: 0px; width: 100%;
    text-shadow: #000 1px 1px 1px;
    padding: 1em;
}

a {
    color: #eee;
}
</style>
</head>

<body>
<div id="container"></div>
<div id="info">
    <a href="http://threejs.org" target="_blank">three.js</a> - 
    <a href="http://www.smartjava.org/content/threejs-render-real-world-terrain-heightmap-using-open-data" target="_blank">terrain</a> with Trackball Controls
</div>

<script src="js/three.min.js"></script>

<script src="js/ShaderTerrain.js"></script>

<script src="js/TrackballControls.js"></script>

<script src="js/Detector.js"></script>
<script src="js/stats.min.js"></script>
<script src="js/dat.gui.min.js"></script>

<script>

if ( ! Detector.webgl ) Detector.addGetWebGLMessage();

var camera, controls, scene, renderer, stats;

init();
animate();

function terrain(texture_heightmap, diffuse) {
    // if no texture given, use the heightmap
    var texture_diffuse = typeof diffuse === 'undefined' ? texture_heightmap :
        THREE.ImageUtils.loadTexture(diffuse);

    // the following configuration defines how the terrain is rendered
    var terrainShader = THREE.ShaderTerrain[ "terrain" ];
    var uniformsTerrain = THREE.UniformsUtils.clone(terrainShader.uniforms);

    // the displacement determines the height of a vector, mapped to
    // the heightmap
    uniformsTerrain[ "tDisplacement" ].value = texture_heightmap;
    uniformsTerrain[ "uDisplacementScale" ].value = 100;

    // the following textures can be use to finetune how
    // the map is shown. These are good defaults for simple
    // rendering
    uniformsTerrain[ "tDiffuse1" ].value = texture_diffuse;
    uniformsTerrain[ "enableDiffuse1" ].value = true;

    // configure the material that reflects our terrain
    var material = new THREE.ShaderMaterial({
        uniforms:       uniformsTerrain,
        vertexShader:   terrainShader.vertexShader,
        fragmentShader: terrainShader.fragmentShader,
        lights:         true,
        fog:            false
    });

    // we use a plane to render our terrain
    var geometry = new THREE.PlaneGeometry(texture_heightmap.image.width,
        texture_heightmap.image.height, 256, 256);
    geometry.computeFaceNormals();
    geometry.computeVertexNormals();
    geometry.computeTangents();

    // create a 3D object to add to the scene
    return new THREE.Mesh(geometry, material);
}

function load_terrain(heightmap, diffuse) {
    // load the heightmap as a texture
    // add a callback when the image is loaded to add it to the scene
    // allowing us to get image.{width,height} for the geometry
    var texture_heightmap = THREE.ImageUtils.loadTexture(heightmap, undefined,
        function() {
            scene.add( terrain(texture_heightmap, diffuse) );
        });
}

function init() {

    // world
    scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2( 0x555555 );

    // terrain
    load_terrain('assets/heightmap.jpg', 'assets/diffuse.jpg');

    // grid
    var grid = new THREE.Mesh( new THREE.PlaneGeometry( 5000, 5000, 50, 50 ),
            new THREE.MeshBasicMaterial( { color: 0x000000, wireframe: true } ) );
    grid.position.set(0, -150, 0);
    scene.add( grid );

    // lights
    var light = new THREE.PointLight(0xffffff);
    scene.add(light);
    light.position.z = 300;
    light.intensity = 1.5;

    // renderer
    renderer = new THREE.WebGLRenderer( { antialias: true } );
    renderer.setClearColor( scene.fog.color, 1 );
    renderer.setSize( window.innerWidth, window.innerHeight );

    // camera
    camera = new THREE.PerspectiveCamera( 60, window.innerWidth /
            window.innerHeight, 1, 10000);
    camera.position.z = 1000;

    // control
    controls = new THREE.TrackballControls( camera, renderer.domElement );

    // add the renderer to the document
    var container = document.getElementById( 'container' );
    container.appendChild( renderer.domElement );

    // stats
    stats = new Stats();
    stats.domElement.style.position = 'absolute';
    stats.domElement.style.top = '0px';
    stats.domElement.style.zIndex = 100;
    container.appendChild( stats.domElement );

    // resize
    window.addEventListener( 'resize', onWindowResize, false );

    // dat
    var gui = new dat.GUI();
    gui.add( light.position, 'x', -100, 100, 1.0 );
    gui.add( light.position, 'y', -100, 100, 1.0 );
    gui.add( light.position, 'z', 0, 1000, 1.0 );
    gui.add( light, 'intensity', 0, 20, 0.1 ).name( 'i' );
    gui.close();

}

function onWindowResize() {

    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();

    renderer.setSize( window.innerWidth, window.innerHeight );
    controls.handleResize();

}

function animate() {

    requestAnimationFrame( animate );
    render();
    stats.update();

}

function render() {

    renderer.render( scene, camera );
    controls.update();

}

</script>

</body>
</html>
